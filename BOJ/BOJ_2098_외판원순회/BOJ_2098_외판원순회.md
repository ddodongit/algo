## [📌 2098번](https://www.acmicpc.net/problem/2098)

## 문제 요약

> 가장 적은 비용을 들이는 외판원의 순회 여행 경로를 구하세요.
>
> $2 ≤ N ≤ 16$<br/>
> $1 ≤ 비용 ≤ 1,000,000$<br/>
>

## 💡 생각 및 풀이

### 1. 순열

순열을 통해 가능한 모든 경로를 탐색하면 시간복잡도가 $O(N!)$으로, N=16인 경우 시간초과가 발생합니다.

따라서 중복 계산되는 것을 줄이기 위해 메모이제이션을 활용하고자 했습니다.

### 2. dp + 비트마스킹

외판원의 이동 경로는 다음과 같이 모든 도시를 한 번씩 방문하고 출발 도시로 돌아오는 사이클 형태입니다.

```
1,2,3,4,1

2,3,4,1,2

3,4,1,2,3
```

따라서, 어느 도시를 출발점으로 정하더라도 최소 비용 경로는 동일하므로, 임의로 1번 도시를 출발점으로 설정했습니다.
이후, 현재 위치한 도시와 지금까지 방문한 도시 상태를 기준으로 최소 비용을 계산하여 dp 배열에 저장합니다.

지금까지 방문한 도시 상태 ```visitBit```는 비트마스킹을 사용하여 메모리와 계산 속도를 줄였습니다.
예를 들어, visitBit = 1011 인 경우, 1,2,4번 도시 방문을 나타냅니다.

dp 배열은 방문하지 않은 상태를 나타내기 위해 -1로 초기화하고,
이미 방문했다면 계산되어있는 값을 반환하고, 아직 방문하지 않았다면 최솟값을 계산하며 갱신합니다.

INF 값은 최대 경로 비용의 합보다 더 큰 값으로 설정했습니다.
최대 비용이 1,000,000이고 도시가 16개이므로, INF는 16 * 1,000,000보다 커야 합니다.
여기서 INF를 Integer.MAX_VALUE로 설정하면 int형인 경우 오버플로우가 발생할 수 있습니다.

결과적으로 dp와 비트마스킹을 통해 모든 방문 상태($2^N$)와 각 상태에서 가능한 도시($N$)를 탐색하며,
시간복잡도 $O(N * 2^N)$로 해결할 수 있습니다.