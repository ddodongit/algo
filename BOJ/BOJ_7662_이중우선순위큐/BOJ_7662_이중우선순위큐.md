## [📌 7662번](https://www.acmicpc.net/problem/7662)

## 문제 요약

> 이중 우선순위 큐 Q에 정수 n를 삽입하거나 최댓값 또는 최솟값을 삭제하는 연산을 k번 처리한 후, 최종적으로 저장된 데이터 중 최댓값과 최솟값을 구하세요.
>
> k ≤ 1,000,000 <br/>
> $-2^{31} ≤ n ≤ 2^{31}$
>
> 동일한 정수가 삽입될 수 있으며, 최댓값(최솟값)을 삭제하는 연산에서 최댓값(최솟값)이 둘 이상인 경우, 하나만 삭제됩니다.
> 두 값은 한 줄에 출력하되 하나의 공백으로 구분하고, 만약 Q가 비어있다면 "EMPTY"를 출력하세요.

## 💡 생각 및 풀이

### 1. PriorityQueue, HashMap

입력 받은 정수들을 오름차순, 내림차순으로 관리하기 위해 우선순위 큐를 각각 ```maxHeap```과 ```minHeap```으로 생성했습니다.
그리고 ```HashMap```을 활용해 정수 각각의 실제 개수를 저장했습니다.

삽입 연산 시 ```maxHeap```, ```minHeap```에 모두 추가하고, ```HashMap```에서 해당 정수의 개수는 1 증가됩니다.

삭제 연산 시

- 최댓값을 삭제하는 경우, ```maxHeap```에 저장되어 있는 값 중 최댓값의 개수를 ```HashMap```을 통해 확인합니다. 해당 키가 존재하면 그 값이 최댓값이므로
  ```maxHeap```에서
  제거하고, 해당 정수의 개수는 1 감소됩니다. 만약 정수의 개수가 0이 된다면 ```HashMap```에서 제거합니다.

  만약 존재하지 않는다면 그 값은 최솟값 삭제 연산에서 삭제된 정수이므로, 존재하는 값이 나올때까지 ```maxHeap.poll()```를 반복합니다.

- 최솟값을 삭제하는 경우도 마찬가지로, ```minHeap```에 저장되어 있는 값 중 최솟값의 개수를 확인합니다. 해당 키가 존재하면 그 값이 최솟값이므로
  ```minHeap```에서 제거하고,
  해당 정수의 개수는 1 감소됩니다.

  이 또한 정수의 개수가 0이 된다면 ```HashMap```에서 제거하고, 해당 키가 ```HashMap```에 존재하지 않았다면, 존재하는 값이 나올떄까지
  ```minHeap.poll()```를 반복합니다.

삭제 연산 시에만 ```maxHeap```, ```minHeap```을 최신 상태로 업데이트 하고 있기 때문에,
전체 k번 연산이 끝난 후 최댓값과 최솟값을 출력할 때도 ```HashMap```에 존재하지 않는 최댓값, 최솟값을 반복해서 제거한 후, 최댓값과 최솟값을 출력해야 합니다. 