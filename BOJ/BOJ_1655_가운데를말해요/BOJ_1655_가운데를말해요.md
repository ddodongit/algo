
## [📌 1655번](https://www.acmicpc.net/problem/1655)


## 문제 요약
> N개의 정수를 하나씩 입력 받을 때마다, 그 때까지 입력받은 수 중에서 중간값을 찾아야 합니다.
> 
> $1 ≤ N ≤ 10^5$
> 
> $-10^4 ≤ 정수 ≤ 10^4$
>

<br/>

## 💡 생각 및 풀이

### 1. TreeSet 사용
숫자들이 **정렬**되어 있어야 하고, 그중에서 가운데에 위치한 숫자를 **인덱스**로 접근해야 한다고 생각했습니다.

그러나 삽입할 때마다 정렬이 가능하며, 특정 요소에 인덱스로 접근할 수 있는 자료구조는 존재하지 않습니다.

따라서 숫자 삽입 시 내부적으로 정렬이 가능한 ```TreeSet```을 선택하고, 이를 ```toArray``` 함수를 사용하여 배열로 변환 후 인덱스로 접근하려고 시도했습니다.

하지만, 모든 요소를 순회하며 배열에 값을 복사할 때 $```O(N)```$의 시간이 소요되며, 매번 숫자 삽입할 때마다 ```toArray```를 호출하면 전체 시간복잡도가 $```O(N^2)```$가 되어 시간 초과가 발생합니다.


### 2. 두 개의 Heap 사용

**빠르게 중간값을 찾아내는 것**이 가장 중요한 포인트로, 삽입 연산의 소요 시간을 $```O(log N)```$으로 유지하며 중간값을 효율적으로 찾기 위해 두 개의 힙을 사용하였습니다.

힙을 기반으로 하는 ```PriorityQueue```를 활용하여,
 ```maxHeap```에는 현재의 중간값 이하의 값들을, ```minHeap```에는 현재의 중간값 이상의 값들을 저장했습니다.
다음과 같은 단계를 통해 ```maxHeap.peek()```은 항상 중간값 이하의 값 중 가장 큰 값, ```minHeap.peek()```은 중간값 이상의 값 중 가장 작은 값을 가지도록 합니다.


1. 입력받은 숫자는 먼저 ```maxHeap```에 추가합니다.
2. 숫자들이 중간값을 기준으로 두 힙에 정확히 나눠져 있도록 값을 조정합니다. 중간값 이하의 값은 ```maxHeap```에, 중간값 이상의 값은 ```minHeap```에 저장되어야 하는 규칙을 위반하지 않도록 두 힙 간의 균형을 유지합니다.
3. 두 힙의 크기 또한 균형을 이루도록 합니다. ```maxHeap```의 크기가 ```minHeap```의 크기와 같거나 1 크도록 유지합니다.

위 단계를 반복하며 ```maxHeap.peek()```은 중간값을 나타내게 되고, 
전체 길이가 짝수인 경우에도 ```maxHeap.peek()```이 중간에 있는 두 수 중에서 더 작은 수이므로 문제의 조건을 충족하게 됩니다.


#### maxHeap 에 먼저 숫자를 추가하는 이유!

전체 개수가 짝수인 경우, 중간에 있는 두 수 중 *작은 값* 을 찾기 위해서는 ```maxHeap```에 추가해야 합니다. 
이 경우, ```maxHeap```의 루트값이 현재 최댓값이 되며, 이는 항상 두 수 중 작은 값입니다. 

만약 ```minHeap```에 먼저 추가한다면, ```minHeap```에서는 항상 중간값 이상의 값을 저장하기 때문에 아래와 같은 경우에서 오류가 발생합니다.


    minHeap에 먼저 넣을 경우

    입력: 1, 5, 2
    
    1:
    maxHeap = [], minHeap = [1] // 중간값: 1

    5:
    maxHeap = [], minHeap = [1, 5] 
    maxHeap = [5], minHeap = [1] // 균형 맞추기, 중간값: 1

    2: 
    maxHeap = [5], minHeap = [1, 2] // 중간값: 1   ** 오류 발생 ** 
  
     
반대로, 전체 개수가 짝수인 경우 중간에 있는 두 수 중 *큰 값* 을 찾는다면 ```minHeap```에 먼저 추가해야 합니다.
이 경우, ```minHeap```의 루트값이 더 큰 값을 가리키게 되어 올바른 중간값을 찾을 수 있습니다.

