## [📌 9527번](https://www.acmicpc.net/problem/9527)

## 문제 요약

> 두 자연수 A, B가 주어졌을 때, A ≤ x ≤ B를 만족하는 모든 x에 대해 x를 이진수로 표현했을 때 1의 개수의 합을 구하세요
>
> $1 ≤ A ≤ B ≤ 10^{16}$ <br/>

## 💡 생각 및 풀이

### 1. bitCount 내장 함수

처음엔 단순히 Long.bitCount() 함수를 활용하려고 했지만,
주어진 수의 범위가 $10^{16}$로 매우 크기 떄문에, A부터 B까지 하나씩 계산하는 방식은 비효율적입니다.

### 2. 누적합

x를 이진수로 표현했을 때, 1의 개수는 반복된 패턴을 가지고 있기 때문에 이를 활용했습니다.

```
 1 = 0000 0001
 2 = 0000 0010
 3 = 0000 0011
 4 = 0000 0100
 5 = 0000 0101
 6 = 0000 0110
 7 = 0000 0111
 8 = 0000 1000
 9 = 0000 1001
10 = 0000 1010
11 = 0000 1011
12 = 0000 1100
13 = 0000 1101
14 = 0000 1110
15 = 0000 1111
16 = 0001 0000
...

```

비트 위치에 따라 다음과 같은 패턴이 반복됩니다:

1비트 위치 : ```[0, 1]```<br/>
2비트 위치 : ```[0, 0, 1, 1]```<br/>
4비트 위치 : ```[0, 0, 0, 0, 1, 1, 1, 1]```<br/>

이러한 규칙을 이용하면 특정 숫자까지 각 비트에서 누적된 1의 개수를 효율적으로 계산할 수 있습니다.

주어진 숫자를 특정 비트 위치(1,2,4,8...)에서 나누면,<br/>
**몫**은 **해당 비트 위치에서 패턴의 반복 횟수**를 나타내고, **나머지**는 **그 패턴이 끝나고 남은 부분**을 나타냅니다.

남은 부분에서 1의 개수를 구할 때, 1이 등장하지 않아 음수가 될 수 있으므로 ```Math.max(0, remain-pos+1)```을 통해 0으로 처리합니다.

따라서, 몫을 이용하여 구한 반복된 패턴에서의 1의 개수와 남은 부분에서 추가로 구한 1의 개수를 합하면,
1부터 num까지의 누적된 1의 개수를 구할 수 있습니다.